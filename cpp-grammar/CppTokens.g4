grammar CppTokens;

// Lexer rules
ALIGNAS: 'alignas';
ALIGNOF: 'alignof';
AND: 'and';
AND_EQ: 'and_eq';
ASM: 'asm';
AUTO: 'auto';
BITAND: 'bitand';
BITOR: 'bitor';
BOOL: 'bool';
BREAK: 'break';
CASE: 'case';
CATCH: 'catch';
CHAR: 'char';
CHAR8_T: 'char8_t';
CHAR16_T: 'char16_t';
CHAR32_T: 'char32_t';
CLASS: 'class';
COMPL: 'compl';
CONCEPT: 'concept';
CONST: 'const';
CONSTEVAL: 'consteval';
CONSTEXPR: 'constexpr';
CONSTINIT: 'constinit';
CONST_CAST: 'const_cast';
CONTINUE: 'continue';
CO_AWAIT: 'co_await';
CO_RETURN: 'co_return';
CO_YIELD: 'co_yield';
DECLTYPE: 'decltype';
DEFAULT: 'default';
DELETE: 'delete';
DO: 'do';
DOUBLE: 'double';
DYNAMIC_CAST: 'dynamic_cast';
ELSE: 'else';
ENUM: 'enum';
EXPLICIT: 'explicit';
EXPORT: 'export';
EXTERN: 'extern';
FALSE: 'false';
FINAL: 'final';
FLOAT: 'float';
FOR: 'for';
FRIEND: 'friend';
GOTO: 'goto';
IF: 'if';
IMPORT: 'import';
INLINE: 'inline';
INT: 'int';
LONG: 'long';
MODULE: 'module';
MUTABLE: 'mutable';
NAMESPACE: 'namespace';
NEW: 'new';
NOEXCEPT: 'noexcept';
NOT: 'not';
NOT_EQ: 'not_eq';
NULLPTR: 'nullptr';
OPERATOR: 'operator';
OR: 'or';
OR_EQ: 'or_eq';
OVERRIDE: 'override';
PRIVATE: 'private';
PROTECTED: 'protected';
PUBLIC: 'public';
REFLEXPR: 'reflexpr';
REGISTER: 'register';
REINTERPRET_CAST: 'reinterpret_cast';
RESTRICT: 'restrict';
RETURN: 'return';
SHORT: 'short';
SIGNED: 'signed';
SIZEOF: 'sizeof';
STATIC: 'static';
STATIC_ASSERT: 'static_assert';
STATIC_CAST: 'static_cast';
STRUCT: 'struct';
SWITCH: 'switch';
SYNCHRONIZED: 'synchronized';
TEMPLATE: 'template';
THIS: 'this';
THREAD_LOCAL: 'thread_local';
THROW: 'throw';
TRUE: 'true';
TRY: 'try';
TYPEDEF: 'typedef';
TYPEID: 'typeid';
TYPENAME: 'typename';
UNION: 'union';
UNSIGNED: 'unsigned';
USING: 'using';
VIRTUAL: 'virtual';
VOID: 'void';
VOLATILE: 'volatile';
WCHAR_T: 'wchar_t';
WHILE: 'while';
XOR: 'xor';
XOR_EQ: 'xor_eq';

STD: 'std';
COUT: 'cout';
CIN: 'cin';
ENDL: 'endl';
STRING: 'string';

INCR: '++';
DECR: '--';
ADD: '+';
SUB: '-';
MUL: '*';
DIV: '/';
MOD: '%';
CARET: '^';
EQUAL: '==';
NEQUAL: '!=';
GREATER: '>';
GREATER_EQUAL: '>=';
LESS: '<';
LESS_EQUAL: '<=';
LOG_AND: '&&';
LOG_OR: '||';
LOG_NOT: '!';
ASSIGN: '=';
ASSIGN_ADD: '+=';
ASSIGN_SUB: '-=';
ASSIGN_MUL: '*=';  
ASSIGN_DIV: '/=';
ASSIGN_MOD: '%=';
ASSIGN_XOR: '^=';
ASSIGN_AND: '&=';
ASSIGN_OR: '|=';
ASSIGN_LSH: '<<=';
ASSIGN_RSH: '>>=';
BIT_AND: '&';
BIT_OR: '|';
BIT_NOT: '~';
SHIFT_LEFT: '<<';
SHIFT_RIGHT: '>>';
ARROW_STAR: '->*';
ARROW: '->';
QUESTION: '?';
DOT_STAR: '.*';
ELLIPSIS: '...';

SEMICOLON: ';';
COLON: ':';
LEFT_PAREN: '(';
RIGHT_PAREN: ')';
LEFT_SQ: '[';
RIGHT_SQ: ']';
LEFT_BRACKET: '{';
RIGHT_BRACKET: '}';
SCOPE_RES: '::';
DOT: '.';
COMMA: ',';

ID: [A-Za-z_][a-zA-Z_0-9]*;

ANY_LITERAL: ANY_INT_LITERAL | FLOAT_LITERAL | STR_LITERAL | CHAR_LITERAL;

ANY_INT_LITERAL: INT_LITERAL | UNSIGNED_INT_LITERAL | LONG_INT_LITERAL | UNSIGNED_LONG_INT_LITERAL | LONG_LONG_INT_LITERAL | UNSIGNED_LONG_LONG_INT_LITERAL;

UNSIGNED_INT_LITERAL: INT_LITERAL ('u' | 'U');
LONG_INT_LITERAL: INT_LITERAL ('l' | 'L');
UNSIGNED_LONG_INT_LITERAL: INT_LITERAL ('u' | 'U') ('l' | 'L');
LONG_LONG_INT_LITERAL: INT_LITERAL ('l' | 'L') ('l' | 'L');
UNSIGNED_LONG_LONG_INT_LITERAL: INT_LITERAL ('u' | 'U') ('l' | 'L') ('l' | 'L');

INT_LITERAL: INT_LITERAL_DEC | INT_LITERAL_HEX | INT_LITERAL_OCT | INT_LITERAL_BIN;

INT_LITERAL_DEC: [1-9][0-9]* | '0';
INT_LITERAL_HEX: '0x' [0-9a-fA-F]+;
INT_LITERAL_OCT: '0' [0-7]+;
INT_LITERAL_BIN: '0b' [01]+;

FLOAT_LITERAL: DOUBLE_LITERAL ('f' | 'F');
DOUBLE_LITERAL: ('.' [0-9]+ | [0-9]+ '.' | [0-9]+ '.' [0-9]+) ([eE] [+-]? [0-9]+)?;

STR_LITERAL: '"' STR_CHAR* '"';
fragment STR_CHAR: ~["\r\n\\] | ESC_SEQ; // "fragment" means that this rule is not a token itself
CHAR_LITERAL: '\'' CHAR_CHAR '\'';
fragment CHAR_CHAR: ~['\r\n\\] | ESC_SEQ;
fragment ESC_SEQ: '\\n' | '\\r' | '\\t' | '\\b' | '\\f' | '\\a' | '\\v' | '\\\\' | '\\\'' | '\\"';

LINECOMMENT: '//' ~ [\r\n]* -> skip;
BLOCKCOMMENT: '/*' .*? '*/' -> skip;
WHITESPACE: [ \t\n\r]+ -> skip;
PREPROCESSOR: '#' .*? '\n' -> skip;
