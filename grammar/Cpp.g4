grammar Cpp;
import CppTokens;

// Parser rules
program: globalDefinition*;
globalDefinition: variableDeclaration | functionDefinition | classDefinition | voidFunctionDefinition;
classDefinition: CLASS identifier LEFT_BRACKET classScope RIGHT_BRACKET SEMICOLON;
classScope: classStatement*;
classStatement: variableDeclaration | constructorDeclaration | methodDefinition | publicArea;
constructorDeclaration: identifier LEFT_PAREN argumentListDefinition? RIGHT_PAREN LEFT_BRACKET constructorScope RIGHT_BRACKET;
constructorScope: constructorStatement*;
constructorStatement: variableDeclaration | coutStatement | cinStatement | ifStatement | whileStatement | forStatement | switchStatement | assignmentStatement | expressionStatement | assignmentStatementInConstructor;
assignmentStatementInConstructor: THIS DOT identifier assignmentOperator expression SEMICOLON;
variableDeclaration: typeSpecifier variableDeclarationItem (COMMA variableDeclarationItem)* SEMICOLON;
variableDeclarationItem: identifier (ASSIGN expression)?;
functionDefinition: typeSpecifier identifier LEFT_PAREN argumentListDefinition? RIGHT_PAREN LEFT_BRACKET executableScope RIGHT_BRACKET;
methodDefinition: typeSpecifier identifier LEFT_PAREN argumentListDefinition? RIGHT_PAREN LEFT_BRACKET executableScope RIGHT_BRACKET | voidType identifier LEFT_PAREN argumentListDefinition? RIGHT_PAREN LEFT_BRACKET voidFunctionScope RIGHT_BRACKET;
voidFunctionDefinition: voidType identifier LEFT_PAREN argumentListDefinition? RIGHT_PAREN LEFT_BRACKET voidFunctionScope RIGHT_BRACKET;
voidFunctionScope: voidFunctionStatement*;
voidFunctionStatement: variableDeclaration | coutStatement | cinStatement | ifStatement | whileStatement | forStatement | switchStatement | assignmentStatement | expressionStatement;
argumentListDefinition: argumentDefinition (COMMA argumentDefinition)*;
argumentDefinition: typeSpecifier identifier;
executableScope: statement*;
statement: variableDeclaration | coutStatement | cinStatement | returnStatement | ifStatement | whileStatement | forStatement | switchStatement | assignmentStatement | expressionStatement;
loopScope: loopStatement*;
loopStatement: variableDeclaration | coutStatement | cinStatement | returnStatement | ifStatement | whileStatement | forStatement | switchStatement | breakStatement | continueStatement | assignmentStatement | expressionStatement;
coutStatement: (STD SCOPE_RES)? COUT (SHIFT_LEFT (expression | coutEndl))+ SEMICOLON;
coutEndl: STD SCOPE_RES ENDL;
cinStatement: (STD SCOPE_RES)? CIN SHIFT_RIGHT identifier SEMICOLON;
returnStatement: RETURN expression SEMICOLON;
ifStatement: IF LEFT_PAREN expression RIGHT_PAREN executableScopeOrStatement ifStatementElseIf* ifStatementElse?;
ifStatementElseIf: ELSE IF LEFT_PAREN expression RIGHT_PAREN executableScopeOrStatement;
ifStatementElse: ELSE executableScopeOrStatement;
whileStatement: WHILE LEFT_PAREN expression RIGHT_PAREN loopScopeOrStatement;
forStatement: FOR LEFT_PAREN forStatementInit forStatementCondition forStatementUpdate RIGHT_PAREN loopScopeOrStatement;
forStatementInit: variableDeclaration | expression SEMICOLON | SEMICOLON;
forStatementCondition: expression SEMICOLON | SEMICOLON;
forStatementUpdate: expression?;
switchStatement: SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_BRACKET switchCase* switchDefault? RIGHT_BRACKET;
switchCase: CASE expression COLON executableScope BREAK SEMICOLON;
switchDefault: DEFAULT COLON executableScope (BREAK SEMICOLON)?;
breakStatement: BREAK SEMICOLON;
continueStatement: CONTINUE SEMICOLON;
executableScopeOrStatement: LEFT_BRACKET executableScope RIGHT_BRACKET | statement;
loopScopeOrStatement: LEFT_BRACKET loopScope RIGHT_BRACKET | loopStatement;
assignmentStatement: identifier assignmentOperator expression SEMICOLON;
assignmentOperator: ASSIGN | ASSIGN_ADD | ASSIGN_SUB | ASSIGN_MUL | ASSIGN_DIV;
expressionStatement: expression SEMICOLON;
expression: atomicExpression | binaryOperationSequence | unaryOperation | functionCall | objectCreation | atributes | methods;
atributes: identifier DOT identifier;
methods: identifier DOT functionCall;
atomicExpression: ANY_LITERAL | ID | LEFT_PAREN expression RIGHT_PAREN;
binaryOperationSequence: atomicExpression (binaryOperator atomicExpression)+;
unaryOperation: unaryPrefixOperator atomicExpression | atomicExpression unaryPostfixOperator;
functionCall: identifier LEFT_PAREN argumentList? RIGHT_PAREN;
objectCreation: identifier identifier ASSIGN constructorCall;
constructorCall: identifier LEFT_PAREN argumentList? RIGHT_PAREN;
argumentList: expression (COMMA expression)*;
typeSpecifier: integerType | stringType | floatType;
unaryPrefixOperator: INCR | DECR | ADD | SUB;
unaryPostfixOperator: INCR | DECR;
binaryOperator: MUL | DIV | ADD | SUB | EQUAL | NEQUAL | GREATER | GREATER_EQUAL | LESS | LESS_EQUAL;
integerType: INT | LONG | SHORT;
stringType: (STD SCOPE_RES)? STRING;
floatType: FLOAT | DOUBLE;
voidType: VOID;
identifier: ID;
publicArea: PUBLIC COLON;
